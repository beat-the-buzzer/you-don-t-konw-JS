## 作用域和闭包

#### 作用域是什么

几乎所有的变成语言都有作用域的概念，作用域能够存储变量的值，并且在之后对这个值进行访问或者修改。

我们需要一个规则来存储变量，并且之后可以方便地找到这些变量，这套规则就是作用域。

#### JavaScript中的编译原理

1、分词/词法分析

这个过程会将由字符组成的字符串分解成有意义的代码块，这些词法块被称为词法单元。例如`var a = 2`被分解成为：

```
var、a、=、2、;
```

空格是否被当做词法单元，取决于空格是否有意义。

2、解析/语法分析

这个过程是将词法单元流转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，这个树被称为`抽象语法树`(AST)

3、代码生成

将AST转换成可执行代码的过程叫做代码生成。

抛开所有细节，简单来说，就是有一种方法，可以将`var a = 2;`的AST转换成一组机器指令，用来创建一个叫做a的变量，并且将一个值储存在a中。 

其实JavaScript引擎编译的时候做了很多复杂的操作，例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化。不过JavaScript不会有太多的时间进行优化，因为JavaScript的编译不是在构建之前。

#### 理解作用域

理解作用域，就是模拟几个人物的对话。

引擎：负责整个JavaScript程序的编译和执行

编译器：负责语法分析和代码生成这些脏活累活

作用域：负责收集并维护所有声明的标识符组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

例: 下面的代码，做了哪些操作

```js
var a = 2;
```

1、遇到var a，编译器会去询问作用域是否有一个名字为a的变量，如果有，就忽略该声明，继续编译，如果没有，编译器就告诉作用域，要创建一个名为a的新变量

2、接下来编译器会去生成代码，这些代码用于处理a = 2这个赋值操作。引擎运行的时候先去访问作用域，看看当前作用域中是否有这个叫做a的变量，如果有，就使用这个变量进行赋值操作，如果没有，就会继续去查找嵌套的作用域，如果无论如何都没有找到这个变量，就会抛出异常。

> 变量赋值的操作会进行两个动作，首先编译器会在当前作用域声明一个变量（如果之前没有声明过），然后在运行的时候引擎会在作用域中查找该变量，如果能找到，就对其赋值。

#### 查找作用域

作用域查找会在找到第一个匹配的标识符时停止。多层嵌套的作用域可以定义同名的标识符，但是这样的话，内部的标识符遮挡了外部的标识符。

```js
var value = 999;
var index = 999;
var arr = [1, 2, 3];
arr.map((value, index) => {
  console.log(value, index);
  return value + index
});
```

上面的例子，console语句不会打印出999。

无论函数在哪里被调用，无论函数如何被调用，它的词法作用域只由函数被声明的位置决定。

#### 欺骗词法

在代码规范ESLint里面，不推荐使用eval和with，因为这两种方式会出现欺骗词法作用域，导致性能下降。

1、eval(...) eval函数可以接受一个字符串作为参数，并且将其中的内容是为好像在书写的时候就存在于程序中这个位置的代码。

```js
function foo(str, a) {
  eval(str); // 欺骗
  console.log(a, b);
}
var b = 2;
foo('var b = 3;', 1); // 1 3
```

我们在上面提到：函数的词法作用域只由函数被声明的位置决定。但是，使用eval函数的时候，是在执行的过程中改变了词法作用域。举个通俗的例子，就是在开发阶段改需求，这样的效率肯定是很低的。

类似的操作还有setTimeout和setInterval函数，它们可以接受一个可执行的字符串作为参数。这种功能不推荐使用。

2、with

with是一个比较冷门的关键字，我甚至从来没有尝试去了解它，只知道不推荐使用。

使用with时会创建新的作用域。具体如何创建这里就不再举例的，总之，在代码运行阶段去改变作用域的行为，严重影响程序的性能。

另外一个不推荐使用eval(...)和with的原因是受严格模式影响或者限制。